# Build, test, sign and package Siren for Windows, macOS, and Linux
#
# Windows: Uses Azure Trusted Signing
# macOS: Uses Developer ID certificates with notarization
# Linux: Unsigned
#
# See docs/macos-signing-setup.md for macOS signing setup instructions

name: .NET Core Desktop

on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Setup GitHub Package Authentication
      run: dotnet nuget add source --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github "https://nuget.pkg.github.com/mythetech/index.json"

    - name: Execute unit tests
      run: dotnet test Siren.Test/Siren.Test.csproj
      env:
        Configuration: Release

  publish:
    needs: test
    if: github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        include:
          - os: windows-latest
            rid: win-x64
            platform: Windows
            icon: Siren/wwwroot/logo.ico
          - os: ubuntu-latest
            rid: linux-x64
            platform: Linux
            icon: Siren/wwwroot/logo5.png
          - os: macos-latest
            rid: osx-x64
            platform: macOS
            icon: Siren/wwwroot/logo.icns
    
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x
        
    - name: Install Velopack CLI
      run: dotnet tool update -g vpk
        
    - name: Get Version
      id: get_version
      run: echo "VERSION=0.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
      shell: bash
    - name: Create Azure Trusted Signing Metadata
      if: matrix.os == 'windows-latest'
      run: |
        $metadata = @{
          Endpoint = "${{ secrets.AZURE_TRUSTED_SIGNING_ENDPOINT }}"
          CodeSigningAccountName = "${{ secrets.AZURE_TRUSTED_SIGNING_ACCOUNT_NAME }}"
          CertificateProfileName = "${{ secrets.AZURE_TRUSTED_SIGNING_CERTIFICATE_PROFILE_NAME }}"
        }
        $metadata | ConvertTo-Json | Out-File -FilePath azure-signing-metadata.json -Encoding utf8
      shell: pwsh
    - name: Azure login
      if: matrix.os == 'windows-latest'
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        allow-no-subscriptions: true
    - name: Install Apple certificates and notary profile
      if: matrix.os == 'macos-latest'
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        INSTALLER_CERTIFICATE_BASE64: ${{ secrets.INSTALLER_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        APPLE_ID: ${{ secrets.APPLE_USERNAME_ID }}
        APPLE_PASSWORD: ${{ secrets.APPLE_SIREN_ID_PASSWORD }}
        APPLE_TEAM: ${{ secrets.APPLE_TEAM_ID }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        CERT_BUILD_PATH=$RUNNER_TEMP/build_certificate.p12
        CERT_INSTALLER_PATH=$RUNNER_TEMP/installer_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERT_BUILD_PATH
        echo -n "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode -o $CERT_INSTALLER_PATH

        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        security import $CERT_BUILD_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security import $CERT_INSTALLER_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH

        xcrun notarytool store-credentials --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM" --password "$APPLE_PASSWORD" --keychain $KEYCHAIN_PATH velopack-profile
    - name: Publish
      run: dotnet publish Siren/Siren.csproj -c Release -r ${{ matrix.rid }} --self-contained -p:PublishSingleFile=true -p:PublishTrimmed=false -o publish/${{ matrix.rid }}
    - name: Create Velopack Release
      if: matrix.os == 'windows-latest'
      run: vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }} --azureTrustedSignFile azure-signing-metadata.json
    - name: Create Velopack Release (unsigned)
      if: matrix.os == 'macos-latest'
      run: |
        vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }}
    - name: Extract and sign macOS app
      if: matrix.os == 'macos-latest'
      run: |
        # Extract the .app from the portable zip
        PORTABLE_ZIP=$(find "releases/${{ matrix.platform }}" -name "*Portable.zip" -type f | head -n 1)
        echo "Extracting from: $PORTABLE_ZIP"
        mkdir -p signed_app
        unzip -q "$PORTABLE_ZIP" -d signed_app
        
        APP_PATH=$(find signed_app -name "*.app" -type d | head -n 1)
        echo "Found app: $APP_PATH"
        
        # Move all non-Mach-O files from MacOS to Resources
        # This prevents codesign from trying to validate static files as code
        echo "Moving non-code files to Contents/Resources..."
        mkdir -p "$APP_PATH/Contents/Resources"
        
        # Move directories (like wwwroot)
        find "$APP_PATH/Contents/MacOS" -mindepth 1 -maxdepth 1 -type d | while read dir; do
          dirname=$(basename "$dir")
          echo "Moving directory: $dirname"
          mv "$dir" "$APP_PATH/Contents/Resources/"
          ln -s "../Resources/$dirname" "$APP_PATH/Contents/MacOS/$dirname"
        done
        
        # Move non-Mach-O files (json, txt, xml, etc.)
        find "$APP_PATH/Contents/MacOS" -maxdepth 1 -type f | while read file; do
          if ! file "$file" | grep -q "Mach-O"; then
            filename=$(basename "$file")
            echo "Moving file: $filename"
            mv "$file" "$APP_PATH/Contents/Resources/"
            ln -s "../Resources/$filename" "$APP_PATH/Contents/MacOS/$filename"
          fi
        done
        
        # Remove any ad-hoc signatures first
        echo "Removing existing signatures..."
        find "$APP_PATH" -type f | while read file; do
          if file "$file" | grep -q "Mach-O"; then
            codesign --remove-signature "$file" 2>/dev/null || true
          fi
        done
        
        # Copy entitlements file
        ENTITLEMENTS="Siren/Siren.entitlements"
        
        # Sign all Mach-O binaries (dylibs and executables) with hardened runtime and entitlements
        # Sign from deepest to shallowest
        echo "Signing all binaries with entitlements..."
        find "$APP_PATH" -type f -name "*.dylib" | while read file; do
          echo "Signing dylib: $file"
          codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
            -f \
            --timestamp \
            --options runtime \
            --entitlements "$ENTITLEMENTS" \
            --keychain $RUNNER_TEMP/app-signing.keychain-db \
            "$file"
        done
        
        # Sign executables (but not the main one yet)
        find "$APP_PATH/Contents/MacOS" -type f ! -name "Siren" | while read file; do
          if file "$file" | grep -q "Mach-O"; then
            echo "Signing executable: $file"
            codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
              -f \
              --timestamp \
              --options runtime \
              --entitlements "$ENTITLEMENTS" \
              --keychain $RUNNER_TEMP/app-signing.keychain-db \
              "$file"
          fi
        done
        
        # Sign the main executable
        echo "Signing main executable..."
        codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
          -f \
          --timestamp \
          --options runtime \
          --entitlements "$ENTITLEMENTS" \
          --keychain $RUNNER_TEMP/app-signing.keychain-db \
          "$APP_PATH/Contents/MacOS/Siren"
        
        # Sign the main app bundle
        echo "Signing app bundle: $APP_PATH"
        codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
          -f \
          --timestamp \
          --options runtime \
          --entitlements "$ENTITLEMENTS" \
          --keychain $RUNNER_TEMP/app-signing.keychain-db \
          "$APP_PATH"
        
        # Verify signature
        echo "Verifying signature..."
        codesign -v --verbose=2 "$APP_PATH"
        
        # Create signed pkg
        echo "Creating signed .pkg..."
        PKG_PATH="releases/${{ matrix.platform }}/Siren-osx-Setup-signed.pkg"
        productbuild --component "$APP_PATH" /Applications --sign "${{ secrets.MACOS_SIGN_INSTALL_IDENTITY }}" --keychain $RUNNER_TEMP/app-signing.keychain-db "$PKG_PATH"
        
        # Replace the original pkg
        rm "releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        mv "$PKG_PATH" "releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        
        # Also update the portable zip with signed app
        rm "$PORTABLE_ZIP"
        cd signed_app && zip -r -q -y "../$PORTABLE_ZIP" . && cd ..
        
        echo "Done signing"
    - name: Notarize macOS Installer
      if: matrix.os == 'macos-latest'
      run: |
        PKG_PATH="releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        echo "Notarizing: $PKG_PATH"
        
        # Submit and capture the output
        SUBMIT_OUTPUT=$(xcrun notarytool submit "$PKG_PATH" --keychain-profile "velopack-profile" --keychain $RUNNER_TEMP/app-signing.keychain-db --wait 2>&1) || true
        echo "$SUBMIT_OUTPUT"
        
        # Extract submission ID
        SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o 'id: [a-f0-9-]*' | head -1 | cut -d' ' -f2)
        
        # Check if notarization succeeded
        if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
          echo "Notarization succeeded!"
          xcrun stapler staple "$PKG_PATH"
        else
          echo "Notarization failed. Fetching log..."
          if [ -n "$SUBMISSION_ID" ]; then
            xcrun notarytool log "$SUBMISSION_ID" --keychain-profile "velopack-profile" --keychain $RUNNER_TEMP/app-signing.keychain-db
          fi
          exit 1
        fi
    - name: Create Velopack Release
      if: matrix.os == 'ubuntu-latest'
      run: vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }}
      
    - name: Clean up keychain
      if: matrix.os == 'macos-latest' && always()
      run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
    
    - name: Map platform to blob path
      id: platform_map
      run: |
        case "${{ matrix.platform }}" in
          Windows)
            echo "BLOB_PLATFORM=windows" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=Siren-Windows.zip" >> $GITHUB_OUTPUT
            ;;
          macOS)
            echo "BLOB_PLATFORM=macos" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=Siren-MacOS.zip" >> $GITHUB_OUTPUT
            ;;
          Linux)
            echo "BLOB_PLATFORM=linux" >> $GITHUB_OUTPUT
            echo "ZIP_NAME=Siren-Linux.zip" >> $GITHUB_OUTPUT
            ;;
        esac
      shell: bash
    
    - name: Prepare release zip file (Windows)
      if: matrix.platform == 'Windows'
      id: prepare_zip_windows
      run: |
        $RELEASE_DIR = "releases/Windows"
        $ZIP_NAME = "${{ steps.platform_map.outputs.ZIP_NAME }}"
        $ZIP_FILE = Join-Path $RELEASE_DIR $ZIP_NAME
        
        $SETUP_EXE = Get-ChildItem -Path $RELEASE_DIR -Filter "*Setup.exe" -File | Select-Object -First 1
        if (-not $SETUP_EXE) {
          $SETUP_EXE = Get-ChildItem -Path $RELEASE_DIR -Filter "*.msi" -File | Select-Object -First 1
        }
        
        if ($SETUP_EXE) {
          Write-Host "Found setup installer, creating zip: $($SETUP_EXE.FullName)"
          Compress-Archive -Path $SETUP_EXE.FullName -DestinationPath $ZIP_FILE -Force
        } else {
          $EXISTING_ZIP = Get-ChildItem -Path $RELEASE_DIR -Filter "*.zip" -File | Select-Object -First 1
          if ($EXISTING_ZIP) {
            Write-Host "No setup installer found, using existing zip"
            Copy-Item $EXISTING_ZIP.FullName $ZIP_FILE -Force
          } else {
            Write-Host "Error: No setup installer or zip file found in $RELEASE_DIR"
            Get-ChildItem -Path $RELEASE_DIR
            exit 1
          }
        }
        
        if (-not (Test-Path $ZIP_FILE)) {
          Write-Host "Error: Failed to create/find zip file at $ZIP_FILE"
          exit 1
        }
        
        "ZIP_FILE=$ZIP_FILE" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        Write-Host "Using zip file: $ZIP_FILE"
        Get-Item $ZIP_FILE | Format-List
      shell: pwsh
    
    - name: Prepare release zip file (macOS/Linux)
      if: matrix.platform != 'Windows'
      id: prepare_zip_unix
      run: |
        RELEASE_DIR="releases/${{ matrix.platform }}"
        ZIP_NAME="${{ steps.platform_map.outputs.ZIP_NAME }}"
        ZIP_FILE="$RELEASE_DIR/$ZIP_NAME"
        
        if [ "${{ matrix.platform }}" = "macOS" ]; then
          PKG_INSTALLER=$(find "$RELEASE_DIR" -name "*.pkg" -type f | head -n 1)
          if [ -n "$PKG_INSTALLER" ]; then
            echo "Found .pkg installer, creating zip: $PKG_INSTALLER"
            cd "$RELEASE_DIR"
            zip -q "$ZIP_NAME" "$(basename "$PKG_INSTALLER")"
            cd - > /dev/null
          else
            EXISTING_ZIP=$(find "$RELEASE_DIR" -name "*Portable.zip" -type f | head -n 1)
            if [ -n "$EXISTING_ZIP" ]; then
              echo "No .pkg found, using Portable.zip"
              cp "$EXISTING_ZIP" "$ZIP_FILE"
            else
              echo "Error: No .pkg installer or Portable.zip found in $RELEASE_DIR"
              ls -la "$RELEASE_DIR"
              exit 1
            fi
          fi
        elif [ "${{ matrix.platform }}" = "Linux" ]; then
          APPIMAGE=$(find "$RELEASE_DIR" -name "*.AppImage" -type f | head -n 1)
          if [ -z "$APPIMAGE" ]; then
            echo "Error: No AppImage found in $RELEASE_DIR"
            ls -la "$RELEASE_DIR"
            exit 1
          fi
          echo "Creating zip from AppImage: $APPIMAGE"
          cd "$RELEASE_DIR"
          zip -q "$ZIP_NAME" "$(basename "$APPIMAGE")"
          cd - > /dev/null
        fi
        
        if [ ! -f "$ZIP_FILE" ]; then
          echo "Error: Failed to create/find zip file at $ZIP_FILE"
          exit 1
        fi
        
        echo "ZIP_FILE=$ZIP_FILE" >> $GITHUB_OUTPUT
        echo "Using zip file: $ZIP_FILE"
        ls -lh "$ZIP_FILE"
      shell: bash
    
    - name: Upload to versioned blob path
      run: |
        VERSION="${{ steps.get_version.outputs.VERSION }}"
        BLOB_PLATFORM="${{ steps.platform_map.outputs.BLOB_PLATFORM }}"
        ZIP_NAME="${{ steps.platform_map.outputs.ZIP_NAME }}"
        if [ "${{ matrix.platform }}" = "Windows" ]; then
          ZIP_FILE="${{ steps.prepare_zip_windows.outputs.ZIP_FILE }}"
        else
          ZIP_FILE="${{ steps.prepare_zip_unix.outputs.ZIP_FILE }}"
        fi
        
        BLOB_PATH="$VERSION/$BLOB_PLATFORM/$ZIP_NAME"
        echo "Uploading to: $BLOB_PATH"
        
        az storage blob upload \
          --account-name stsirendownloads \
          --container-name release \
          --name "$BLOB_PATH" \
          --file "$ZIP_FILE" \
          --overwrite \
          --sas-token "${{ secrets.SIREN_BLOB_SAS_TOKEN }}"
      shell: bash
    
    - name: Upload to latest blob path
      run: |
        BLOB_PLATFORM="${{ steps.platform_map.outputs.BLOB_PLATFORM }}"
        ZIP_NAME="${{ steps.platform_map.outputs.ZIP_NAME }}"
        if [ "${{ matrix.platform }}" = "Windows" ]; then
          ZIP_FILE="${{ steps.prepare_zip_windows.outputs.ZIP_FILE }}"
        else
          ZIP_FILE="${{ steps.prepare_zip_unix.outputs.ZIP_FILE }}"
        fi

        BLOB_PATH="latest/$BLOB_PLATFORM/$ZIP_NAME"
        echo "Uploading to: $BLOB_PATH"

        az storage blob upload \
          --account-name stsirendownloads \
          --container-name release \
          --name "$BLOB_PATH" \
          --file "$ZIP_FILE" \
          --overwrite \
          --sas-token "${{ secrets.SIREN_BLOB_SAS_TOKEN }}"
      shell: bash

    - name: Upload Velopack release files for auto-updates
      run: |
        BLOB_PLATFORM="${{ steps.platform_map.outputs.BLOB_PLATFORM }}"
        RELEASE_DIR="releases/${{ matrix.platform }}"

        echo "Uploading Velopack release files from $RELEASE_DIR to releases/$BLOB_PLATFORM"

        # Upload all files in the release directory (RELEASES, nupkg, etc.)
        for file in "$RELEASE_DIR"/*; do
          if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo "Uploading: $filename"
            az storage blob upload \
              --account-name stsirendownloads \
              --container-name releases \
              --name "$BLOB_PLATFORM/$filename" \
              --file "$file" \
              --overwrite \
              --sas-token "${{ secrets.SIREN_BLOB_SAS_TOKEN }}"
          fi
        done
      shell: bash

    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Siren-${{ matrix.platform }}-${{ steps.get_version.outputs.VERSION }}
        path: releases/${{ matrix.platform }}
