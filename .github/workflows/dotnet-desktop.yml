# Build, test, sign and package Siren for Windows, macOS, and Linux
#
# Windows: Uses Azure Trusted Signing
# macOS: Uses Developer ID certificates with notarization
# Linux: Unsigned
#
# See docs/macos-signing-setup.md for macOS signing setup instructions

name: .NET Core Desktop

on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x

    - name: Setup GitHub Package Authentication
      run: dotnet nuget add source --username USERNAME --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text --name github "https://nuget.pkg.github.com/mythetech/index.json"

    - name: Execute unit tests
      run: dotnet test Siren.Test/Siren.Test.csproj
      env:
        Configuration: Release

  publish:
    needs: test
    if: github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        include:
          - os: windows-latest
            rid: win-x64
            platform: Windows
            icon: Siren/wwwroot/logo.ico
          - os: ubuntu-latest
            rid: linux-x64
            platform: Linux
            icon: Siren/wwwroot/logo5.png
          - os: macos-latest
            rid: osx-x64
            platform: macOS
            icon: Siren/wwwroot/logo.icns
    
    runs-on: ${{ matrix.os }}
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x
        
    - name: Install Velopack CLI
      run: dotnet tool update -g vpk
        
    - name: Get Version
      id: get_version
      run: echo "VERSION=0.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
      shell: bash
    - name: Create Azure Trusted Signing Metadata
      if: matrix.os == 'windows-latest'
      run: |
        $metadata = @{
          Endpoint = "${{ secrets.AZURE_TRUSTED_SIGNING_ENDPOINT }}"
          CodeSigningAccountName = "${{ secrets.AZURE_TRUSTED_SIGNING_ACCOUNT_NAME }}"
          CertificateProfileName = "${{ secrets.AZURE_TRUSTED_SIGNING_CERTIFICATE_PROFILE_NAME }}"
        }
        $metadata | ConvertTo-Json | Out-File -FilePath azure-signing-metadata.json -Encoding utf8
      shell: pwsh
    - name: Azure login
      if: matrix.os == 'windows-latest'
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        allow-no-subscriptions: true
      env:
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
    - name: Install Apple certificates and notary profile
      if: matrix.os == 'macos-latest'
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        INSTALLER_CERTIFICATE_BASE64: ${{ secrets.INSTALLER_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        APPLE_ID: ${{ secrets.APPLE_USERNAME_ID }}
        APPLE_PASSWORD: ${{ secrets.APPLE_SIREN_ID_PASSWORD }}
        APPLE_TEAM: ${{ secrets.APPLE_TEAM_ID }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        CERT_BUILD_PATH=$RUNNER_TEMP/build_certificate.p12
        CERT_INSTALLER_PATH=$RUNNER_TEMP/installer_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERT_BUILD_PATH
        echo -n "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode -o $CERT_INSTALLER_PATH

        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        security import $CERT_BUILD_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security import $CERT_INSTALLER_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH

        xcrun notarytool store-credentials --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM" --password "$APPLE_PASSWORD" --keychain $KEYCHAIN_PATH velopack-profile
    - name: Publish
      run: dotnet publish Siren/Siren.csproj -c Release -r ${{ matrix.rid }} --self-contained -p:PublishSingleFile=true -p:PublishTrimmed=false -o publish/${{ matrix.rid }}
    - name: Create Velopack Release
      if: matrix.os == 'windows-latest'
      env:
        AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      run: vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }} --azureTrustedSignFile azure-signing-metadata.json
    - name: Create Velopack Release (unsigned)
      if: matrix.os == 'macos-latest'
      run: |
        vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }}
    - name: Extract and sign macOS app
      if: matrix.os == 'macos-latest'
      run: |
        # Extract the .app from the portable zip
        PORTABLE_ZIP=$(find "releases/${{ matrix.platform }}" -name "*Portable.zip" -type f | head -n 1)
        echo "Extracting from: $PORTABLE_ZIP"
        mkdir -p signed_app
        unzip -q "$PORTABLE_ZIP" -d signed_app
        
        APP_PATH=$(find signed_app -name "*.app" -type d | head -n 1)
        echo "Found app: $APP_PATH"
        
        # Move all non-Mach-O files from MacOS to Resources
        # This prevents codesign from trying to validate static files as code
        echo "Moving non-code files to Contents/Resources..."
        mkdir -p "$APP_PATH/Contents/Resources"
        
        # Move directories (like wwwroot)
        find "$APP_PATH/Contents/MacOS" -mindepth 1 -maxdepth 1 -type d | while read dir; do
          dirname=$(basename "$dir")
          echo "Moving directory: $dirname"
          mv "$dir" "$APP_PATH/Contents/Resources/"
          ln -s "../Resources/$dirname" "$APP_PATH/Contents/MacOS/$dirname"
        done
        
        # Move non-Mach-O files (json, txt, xml, etc.)
        find "$APP_PATH/Contents/MacOS" -maxdepth 1 -type f | while read file; do
          if ! file "$file" | grep -q "Mach-O"; then
            filename=$(basename "$file")
            echo "Moving file: $filename"
            mv "$file" "$APP_PATH/Contents/Resources/"
            ln -s "../Resources/$filename" "$APP_PATH/Contents/MacOS/$filename"
          fi
        done
        
        # Remove any ad-hoc signatures first
        echo "Removing existing signatures..."
        find "$APP_PATH" -type f | while read file; do
          if file "$file" | grep -q "Mach-O"; then
            codesign --remove-signature "$file" 2>/dev/null || true
          fi
        done
        
        # Copy entitlements file
        ENTITLEMENTS="Siren/Siren.entitlements"
        
        # Sign all Mach-O binaries (dylibs and executables) with hardened runtime and entitlements
        # Sign from deepest to shallowest
        echo "Signing all binaries with entitlements..."
        find "$APP_PATH" -type f -name "*.dylib" | while read file; do
          echo "Signing dylib: $file"
          codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
            -f \
            --timestamp \
            --options runtime \
            --entitlements "$ENTITLEMENTS" \
            --keychain $RUNNER_TEMP/app-signing.keychain-db \
            "$file"
        done
        
        # Sign executables (but not the main one yet)
        find "$APP_PATH/Contents/MacOS" -type f ! -name "Siren" | while read file; do
          if file "$file" | grep -q "Mach-O"; then
            echo "Signing executable: $file"
            codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
              -f \
              --timestamp \
              --options runtime \
              --entitlements "$ENTITLEMENTS" \
              --keychain $RUNNER_TEMP/app-signing.keychain-db \
              "$file"
          fi
        done
        
        # Sign the main executable
        echo "Signing main executable..."
        codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
          -f \
          --timestamp \
          --options runtime \
          --entitlements "$ENTITLEMENTS" \
          --keychain $RUNNER_TEMP/app-signing.keychain-db \
          "$APP_PATH/Contents/MacOS/Siren"
        
        # Sign the main app bundle
        echo "Signing app bundle: $APP_PATH"
        codesign -s "${{ secrets.MACOS_SIGN_APP_IDENTITY }}" \
          -f \
          --timestamp \
          --options runtime \
          --entitlements "$ENTITLEMENTS" \
          --keychain $RUNNER_TEMP/app-signing.keychain-db \
          "$APP_PATH"
        
        # Verify signature
        echo "Verifying signature..."
        codesign -v --verbose=2 "$APP_PATH"
        
        # Create signed pkg
        echo "Creating signed .pkg..."
        PKG_PATH="releases/${{ matrix.platform }}/Siren-osx-Setup-signed.pkg"
        productbuild --component "$APP_PATH" /Applications --sign "${{ secrets.MACOS_SIGN_INSTALL_IDENTITY }}" --keychain $RUNNER_TEMP/app-signing.keychain-db "$PKG_PATH"
        
        # Replace the original pkg
        rm "releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        mv "$PKG_PATH" "releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        
        # Also update the portable zip with signed app
        rm "$PORTABLE_ZIP"
        cd signed_app && zip -r -q -y "../$PORTABLE_ZIP" . && cd ..
        
        echo "Done signing"
    - name: Notarize macOS Installer
      if: matrix.os == 'macos-latest'
      run: |
        PKG_PATH="releases/${{ matrix.platform }}/Siren-osx-Setup.pkg"
        echo "Notarizing: $PKG_PATH"
        
        # Submit and capture the output
        SUBMIT_OUTPUT=$(xcrun notarytool submit "$PKG_PATH" --keychain-profile "velopack-profile" --keychain $RUNNER_TEMP/app-signing.keychain-db --wait 2>&1) || true
        echo "$SUBMIT_OUTPUT"
        
        # Extract submission ID
        SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o 'id: [a-f0-9-]*' | head -1 | cut -d' ' -f2)
        
        # Check if notarization succeeded
        if echo "$SUBMIT_OUTPUT" | grep -q "status: Accepted"; then
          echo "Notarization succeeded!"
          xcrun stapler staple "$PKG_PATH"
        else
          echo "Notarization failed. Fetching log..."
          if [ -n "$SUBMISSION_ID" ]; then
            xcrun notarytool log "$SUBMISSION_ID" --keychain-profile "velopack-profile" --keychain $RUNNER_TEMP/app-signing.keychain-db
          fi
          exit 1
        fi
    - name: Create Velopack Release
      if: matrix.os == 'ubuntu-latest'
      run: vpk pack -u "Siren" -v ${{ steps.get_version.outputs.VERSION }} -o "releases/${{ matrix.platform }}" -p "publish/${{ matrix.rid }}" --icon ${{ matrix.icon }}
      
    - name: Clean up keychain
      if: matrix.os == 'macos-latest' && always()
      run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
      
    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Siren-${{ matrix.platform }}-${{ steps.get_version.outputs.VERSION }}
        path: releases/${{ matrix.platform }}
