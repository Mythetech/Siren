@using Siren.Components.Http
@using Siren.Components.Http.Models
@using Siren.Components.Http.Commands
@using Siren.Components.Collections
@using Siren.Components.Variables
@using Siren.Components.History
@using Mythetech.Framework.Infrastructure
@using System.Text.Json
@using Microsoft.Extensions.Logging
@using Mythetech.Framework.Infrastructure.MessageBus
@using Mythetech.Framework.Infrastructure.Plugins
@using Siren.Components.Settings
@using MouseEvent = MudBlazor.MouseEvent
@using Mythetech.Framework.Infrastructure.Plugins.Components
@implements IDisposable

<SirenStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft"
        Dense="true" ListClass="pa-1">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">File
            </MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.Add" OnClick="HandleNewRequest">New Request</MudMenuItem>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.Export" OnClick="HandleSaveRequestToFile">Save Request
            </MudMenuItem>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.UrlImport" OnClick="HandleImportRequest">Import Request
            </MudMenuItem>
            <MudDivider />
            <MudMenuItem Class="rounded" Icon="@SirenIcons.Export" OnClick="@(async () => await HandleSaveResponse())"
                Disabled="@(AppState.Active?.Response == null)">Save Response</MudMenuItem>
        </ChildContent>
    </MudMenu>

    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft"
        Dense="true" ListClass="pa-1">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">Edit
            </MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.FormatIndent" OnClick="HandleFormatRequest">Format Request
            </MudMenuItem>
        </ChildContent>
    </MudMenu>

    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft"
             Dense="true" ListClass="pa-1 max-w-160">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">Tools
            </MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenu Label="History" StartIcon="@SirenIcons.History" Dense="true" ListClass="pa-1">
                <MudMenuItem Class="rounded" Icon="@SirenIcons.DeleteHistory" OnClick="HandleClearHistory">Clear
                </MudMenuItem>
            </MudMenu>
            <MudMenu Label="Collections" StartIcon="@SirenIcons.Collections" Dense="true" ListClass="pa-1">
                <MudMenuItem Class="rounded" Icon="@SirenIcons.AddCollection" OnClick="HandleCreateCollection">Create
                    new</MudMenuItem>
                <MudMenu Label="Import from" StartIcon="@SirenIcons.UrlImport" Dense="true" ListClass="pa-1">
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.UrlImport" OnClick="HandleImportFromOpenApi">OpenAPI
                    </MudMenuItem>
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.UrlImport" OnClick="HandleImportPostmanCollection">
                        Postman Collection</MudMenuItem>
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.UrlImport" OnClick="HandleImportBrunoCollection">
                        Bruno Collection</MudMenuItem>
                </MudMenu>
                <MudMenuItem Class="rounded" Icon="@SirenIcons.Export" OnClick="HandleExportToJson">Export to JSON
                </MudMenuItem>
            </MudMenu>
            <MudMenu Label="Variables" StartIcon="@SirenIcons.Variables" Dense="true" ListClass="pa-1">
                <MudMenuItem Class="rounded-lg" Icon="@SirenIcons.Add" OnClick="HandleAddEnvironment">Add Environment
                </MudMenuItem>
                <MudMenuItem Class="rounded-lg" Icon="@SirenIcons.Add" OnClick="HandleAddVariable">Add Variable
                </MudMenuItem>
                <MudDivider />
                <MudMenu Label="Environments" StartIcon="@SirenIcons.Environment" Dense="true" ListClass="pa-1">
                    <MudMenuItem
                        Class="@($"{(string.IsNullOrEmpty(AppState.ActiveEnvironment) ? "list-item-active" : "")} rounded-lg")"
                        OnClick="@(() => AppState.ActiveEnvironment = null)">None</MudMenuItem>
                    @foreach (var env in AvailableEnvironments)
                    {
                        <MudMenuItem
                            Class="@($"{(env.Equals(AppState.ActiveEnvironment) ? "list-item-active" : "")} rounded-lg")"
                            OnClick="@(() => AppState.ActiveEnvironment = env)">@env</MudMenuItem>
                    }
                </MudMenu>
            </MudMenu>
        </ChildContent>
    </MudMenu>
    @if (Settings.PluginState)
    {
        <StandardPluginMenu MenuText="Plugins"
                            ListClass="pa-1"
                            ItemClass="rounded"
                            ButtonClass="text-transform-none"/>
    }
</SirenStack>

@code {
    [Inject]
    protected SirenAppState AppState { get; set; } = default!;

    [Inject]
    protected ICollectionsService CollectionsService { get; set; } = default!;

    [Inject]
    protected VariableState VariableState { get; set; } = default!;

    [Inject]
    protected IHistoryService HistoryService { get; set; } = default!;

    [Inject]
    protected IDialogService DialogService { get; set; } = default!;

    [Inject]
    protected ISnackbar Snackbar { get; set; } = default!;

    [Inject]
    protected IJsApiService JsApiService { get; set; } = default!;

    [Inject]
    protected ILogger<MenuBar> Logger { get; set; } = default!;

    [Inject]
    protected IMessageBus MessageBus { get; set; } = default!;

    [Inject] protected PluginState PluginState { get; set; } = default!;

    [Inject] protected SettingsState Settings { get; set; } = default!;

    private List<string> AvailableEnvironments = new();

    protected override void OnInitialized()
    {
        LoadEnvironments();
        AppState.OnActiveEnvironmentChanged += HandleEnvironmentChanged;
        VariableState.StateChanged += HandleStateChanged;
        PluginState.StateChanged += HandlePluginStateChanged;
        Settings.SettingsChanged += HandleSettingsStateChanged;
    }

    private void HandleSettingsStateChanged(SettingsState s) => StateHasChanged();

    private void HandlePluginStateChanged(object? sender, EventArgs args) => StateHasChanged();

    private void HandleStateChanged()
    {
        LoadEnvironments();
    }

    private void LoadEnvironments()
    {
        AvailableEnvironments = VariableState.Environments.Select(e => e.Name).ToList();
        StateHasChanged();
    }

    private void HandleEnvironmentChanged(string? environment)
    {
        StateHasChanged();
    }

    public void Dispose()
    {
        AppState.OnActiveEnvironmentChanged -= HandleEnvironmentChanged;
        VariableState.StateChanged -= HandleStateChanged;
        PluginState.StateChanged -= HandlePluginStateChanged;
        Settings.SettingsChanged -= HandleSettingsStateChanged;
    }

    private void HandleNewRequest()
    {
        var networkRequest = new SirenNetworkRequest()
        {
            Name = "New Request",
            Request = new(),
        };

        AppState.AddNetworkRequest(networkRequest);
        AppState.SetActive(networkRequest.Id);
    }

    private async Task HandleSaveRequestToFile()
    {
        if (AppState.Active?.Request == null)
        {
            Snackbar.Add("No active request to save", Severity.Warning);
            return;
        }

        var request = AppState.Active.Request;

        var (editorBody, _) = await AppState.RequestBodyContentAsync();
        if (request.BodyType == RequestBodyType.Raw && !string.IsNullOrEmpty(editorBody))
        {
            request.RawBody = editorBody;
        }

        var bodyTypeString = request.BodyType switch
        {
            RequestBodyType.None => "none",
            RequestBodyType.Raw => "raw",
            RequestBodyType.FormData => "form-data",
            RequestBodyType.Binary => "binary",
            _ => "raw"
        };

        var command = new SaveRequest(
        Method: request.Method?.Method ?? "GET",
        RequestUri: request.RequestUri,
        DisplayUri: request.DisplayUri,
        QueryParameters: request.QueryParameters,
        Headers: request.Headers,
        FormData: request.FormData,
        ContentType: request.ContentType,
        Body: request.RawBody,
        BodyType: bodyTypeString,
        Timeout: request.Timeout,
        RetryAttempts: request.RetryAttempts,
        Id: request.Id
        );

        await MessageBus.PublishAsync(command);
    }

    private async Task HandleImportRequest()
    {
        await MessageBus.PublishAsync(new ImportRequest());
    }

    private async Task HandleSaveResponse()
    {
        if (AppState.Active?.Response == null)
        {
            Snackbar.Add("No response to save", Severity.Warning);
            return;
        }

        var response = AppState.Active.Response;
        var command = new SaveResponse(
        HttpStatusCode: response.HttpStatusCode,
        StatusCode: response.StatusCode,
        Duration: response.Duration,
        RequestSize: response.RequestSize,
        ResponseSize: response.ResponseSize,
        Headers: response.Headers,
        ActualRequestHeaders: response.ActualRequestHeaders,
        ResponseText: response.ResponseText,
        Timestamp: DateTimeOffset.UtcNow
        );

        await MessageBus.PublishAsync(command);
    }

    private void HandleFormatRequest()
    {
        AppState.TriggerFormatRequest();
    }


    private async Task HandleClearHistory()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<DeleteHistoryDialog>("Delete History", options);

        var result = await dialogRef.Result;

        if (!result.Canceled)
        {
            try
            {
                HistoryService.DeleteAllHistoryRecords();
                Snackbar.Add("Successfully deleted history", Severity.Success, configure: opts =>
                {
                    opts.Icon = SirenIcons.History;
                });
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error deleting history");
                Snackbar.Add("Error deleting history", Severity.Error);
            }
        }
    }

    private void HandleCreateCollection()
    {
        CollectionsService.CreateCollection("Untitled", default!);
        Snackbar.Add("Created collection", Severity.Success, opts =>
        {
            opts.SuccessIcon = SirenIcons.Collection;
        });
    }

    private async Task HandleImportFromOpenApi()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<ImportDialog>("Open API Import", options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is Collection collection)
        {
            CollectionsService.UpdateCollection(collection);
            Snackbar.Add("Imported from OpenAPI", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.UrlImport;
            });
        }
    }

    private async Task HandleImportPostmanCollection()
    {
        await MessageBus.PublishAsync(new Siren.Components.Collections.Commands.ImportPostmanCollection());
    }

    private async Task HandleImportBrunoCollection()
    {
        await MessageBus.PublishAsync(new Siren.Components.Collections.Commands.ImportBrunoCollection());
    }

    private async Task HandleExportToJson()
    {
        try
        {
            var collections = CollectionsService.GetCollections();

            if (collections.Count == 0)
            {
                Snackbar.Add("No collections to export", Severity.Warning);
                return;
            }

            var json = JsonSerializer.Serialize(collections, new JsonSerializerOptions
            {
                WriteIndented = true
            });

            await JsApiService.CopyToClipboardAsync(json);
            Snackbar.Add("Collections exported to JSON (copied to clipboard)", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Collection;
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting collections");
            Snackbar.Add("Error exporting collections", Severity.Error);
        }
    }

    private async Task HandleAddEnvironment()
    {
        var parameters = new DialogParameters();
        parameters.Add("Label", "Environment name:");
        parameters.Add("Placeholder", "New Environment");
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<InputDialog>("Add Environment", parameters, options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is string environmentName && !string.IsNullOrWhiteSpace(environmentName))
        {
            var variable = Variable.Create("Key", "Value", false, environmentName);
            VariableState.CreateVariable(variable);
            Snackbar.Add($"Created environment '{environmentName}'", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Environment;
            });
        }
    }

    private async Task HandleAddVariable()
    {
        var activeEnvironment = AppState.ActiveEnvironment ?? VariableGroups.SystemGroup;

        var keyParameters = new DialogParameters();
        keyParameters.Add("Label", "Variable key:");
        keyParameters.Add("Placeholder", "Key");
        var keyOptions = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var keyDialog = await DialogService.ShowAsync<InputDialog>("Add Variable", keyParameters, keyOptions);

        var keyResult = await keyDialog.Result;

        if (keyResult.Canceled || !(keyResult.Data is string key) || string.IsNullOrWhiteSpace(key))
            return;

        var valueParameters = new DialogParameters();
        valueParameters.Add("Label", "Variable value:");
        valueParameters.Add("Placeholder", "Value");
        var valueOptions = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var valueDialog = await DialogService.ShowAsync<InputDialog>("Add Variable", valueParameters, valueOptions);

        var valueResult = await valueDialog.Result;

        if (!valueResult.Canceled && valueResult.Data is string value)
        {
            var variable = Variable.Create(key, value, false, activeEnvironment);
            VariableState.CreateVariable(variable);
            Snackbar.Add($"Added variable '{key}' to {activeEnvironment}", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Variables;
            });
        }
    }
}