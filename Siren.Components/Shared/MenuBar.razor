@using Siren.Components.Http
@using Siren.Components.Collections
@using Siren.Components.Variables
@using Siren.Components.History
@using System.Text.Json
@using Microsoft.Extensions.Logging
@using Siren.Components.Settings
@using MouseEvent = MudBlazor.MouseEvent
@implements IDisposable

<SirenStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft" Dense="true" ListClass="pa-1">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">File</MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.Add" OnClick="HandleNewRequest">New Request</MudMenuItem>
            <MudMenuItem Disabled="true" Class="rounded" Icon="@SirenIcons.AddToCollection" OnClick="HandleSaveRequest">Save Request</MudMenuItem>
        </ChildContent>
    </MudMenu>

    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft" Dense="true" ListClass="pa-1">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">Edit</MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.FormatIndent" OnClick="HandleFormatRequest">Format Request</MudMenuItem>
        </ChildContent>
    </MudMenu>

    <MudMenu ActivationEvent="MouseEvent.MouseOver" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft" Dense="true" ListClass="pa-1 max-w-160">
        <ActivatorContent>
            <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Inherit" Class="text-transform-none">Tools</MudButton>
        </ActivatorContent>
        <ChildContent>
            <MudMenu Label="History" StartIcon="@SirenIcons.History" Dense="true" ListClass="pa-1">
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.DeleteHistory" OnClick="HandleClearHistory">Clear</MudMenuItem>
            </MudMenu>
            <MudMenu Label="Collections" StartIcon="@SirenIcons.Collections" Dense="true" ListClass="pa-1">
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.AddCollection" OnClick="HandleCreateCollection">Create new</MudMenuItem>
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.UrlImport" OnClick="HandleImportFromOpenApi">Import from OpenAPI</MudMenuItem>
                    <MudMenuItem Class="rounded" Icon="@SirenIcons.Export" OnClick="HandleExportToJson">Export to JSON</MudMenuItem>
            </MudMenu>
            <MudMenu Label="Variables" StartIcon="@SirenIcons.Variables" Dense="true" ListClass="pa-1">
                    <MudMenuItem Class="rounded-lg" Icon="@SirenIcons.Add" OnClick="HandleAddEnvironment">Add Environment</MudMenuItem>
                    <MudMenuItem Class="rounded-lg" Icon="@SirenIcons.Add" OnClick="HandleAddVariable">Add Variable</MudMenuItem>
                    <MudDivider />
                    <MudMenu Label="Environments" StartIcon="@SirenIcons.Environment" Dense="true" ListClass="pa-1">
                        <MudMenuItem Class="@($"{(string.IsNullOrEmpty(AppState.ActiveEnvironment) ? "list-item-active" : "")} rounded-lg")" OnClick="@(() => AppState.ActiveEnvironment = null)">None</MudMenuItem>
                        @foreach (var env in AvailableEnvironments)
                        {
                            <MudMenuItem Class="@($"{(env.Equals(AppState.ActiveEnvironment) ? "list-item-active" : "")} rounded-lg")" OnClick="@(() => AppState.ActiveEnvironment = env)">@env</MudMenuItem>
                        }
                    </MudMenu>
            </MudMenu>
            <MudMenuItem Class="rounded" Icon="@SirenIcons.Settings" OnClick="HandleOpenSettings">Settings</MudMenuItem>
        </ChildContent>
    </MudMenu>
</SirenStack>

@code {
    [Inject]
    protected SirenAppState AppState { get; set; } = default!;

    [Inject]
    protected ICollectionsService CollectionsService { get; set; } = default!;

    [Inject]
    protected IVariableService VariableService { get; set; } = default!;

    [Inject]
    protected IHistoryService HistoryService { get; set; } = default!;

    [Inject]
    protected IDialogService DialogService { get; set; } = default!;

    [Inject]
    protected ISnackbar Snackbar { get; set; } = default!;

    [Inject]
    protected IJsApiService JsApiService { get; set; } = default!;

    [Inject]
    protected ILogger<MenuBar> Logger { get; set; } = default!;

    private List<string> AvailableEnvironments = new();

    protected override void OnInitialized()
    {
        LoadEnvironments();
        AppState.OnActiveEnvironmentChanged += HandleEnvironmentChanged;
    }

    private void LoadEnvironments()
    {
        var environments = VariableService.GetEnvironments();
        AvailableEnvironments = environments.Select(e => e.Name).ToList();
        StateHasChanged();
    }

    private void HandleEnvironmentChanged(string? environment)
    {
        StateHasChanged();
    }

    public void Dispose()
    {
        AppState.OnActiveEnvironmentChanged -= HandleEnvironmentChanged;
    }

    private void HandleNewRequest()
    {
        var networkRequest = new SirenNetworkRequest()
        {
            Name = "New Request",
            Request = new(),
        };

        AppState.AddNetworkRequest(networkRequest);
        AppState.SetActive(networkRequest.Id);
    }

    private async Task HandleSaveRequest()
    {
        if (AppState.Active?.Request == null)
        {
            Snackbar.Add("No active request to save", Severity.Warning);
            return;
        }

        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<UpsertRequestDialog>("Save Request", options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is HttpRequest request)
        {
            var collections = CollectionsService.GetCollections();
            
            if (collections.Count == 0)
            {
                var newCollection = CollectionsService.CreateCollection("My Collection", new[] { request });
                Snackbar.Add("Created collection and saved request", Severity.Success, opts =>
                {
                    opts.SuccessIcon = SirenIcons.Collection;
                });
            }
            else
            {
                var firstCollection = collections.First();
                CollectionsService.AddRequestToCollection(firstCollection.Id, request);
                Snackbar.Add("Request saved to collection", Severity.Success, opts =>
                {
                    opts.SuccessIcon = SirenIcons.CollectionItemAdded;
                });
            }
        }
    }

    private void HandleFormatRequest()
    {
        AppState.TriggerFormatRequest();
    }


    private async Task HandleClearHistory()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<DeleteHistoryDialog>("Delete History", options);

        var result = await dialogRef.Result;

        if (!result.Canceled)
        {
            try
            {
                HistoryService.DeleteAllHistoryRecords();
                Snackbar.Add("Successfully deleted history", Severity.Success, configure: opts =>
                {
                    opts.Icon = SirenIcons.History;
                });
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error deleting history");
                Snackbar.Add("Error deleting history", Severity.Error);
            }
        }
    }

    private void HandleCreateCollection()
    {
        CollectionsService.CreateCollection("Untitled", default!);
        Snackbar.Add("Created collection", Severity.Success, opts =>
        {
            opts.SuccessIcon = SirenIcons.Collection;
        });
    }

    private async Task HandleImportFromOpenApi()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<ImportDialog>("Open API Import", options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is Collection collection)
        {
            CollectionsService.UpdateCollection(collection);
            Snackbar.Add("Imported from OpenAPI", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.UrlImport;
            });
        }
    }

    private async Task HandleExportToJson()
    {
        try
        {
            var collections = CollectionsService.GetCollections();
            
            if (collections.Count == 0)
            {
                Snackbar.Add("No collections to export", Severity.Warning);
                return;
            }

            var json = JsonSerializer.Serialize(collections, new JsonSerializerOptions
            {
                WriteIndented = true
            });

            await JsApiService.CopyToClipboardAsync(json);
            Snackbar.Add("Collections exported to JSON (copied to clipboard)", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Collection;
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error exporting collections");
            Snackbar.Add("Error exporting collections", Severity.Error);
        }
    }

    private async Task HandleAddEnvironment()
    {
        var parameters = new DialogParameters();
        parameters.Add("Label", "Environment name:");
        parameters.Add("Placeholder", "New Environment");
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var dialogRef = await DialogService.ShowAsync<InputDialog>("Add Environment", parameters, options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is string environmentName && !string.IsNullOrWhiteSpace(environmentName))
        {
            var variable = Variable.Create("Key", "Value", false, environmentName);
            VariableService.CreateVariable(variable);
            LoadEnvironments();
            Snackbar.Add($"Created environment '{environmentName}'", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Environment;
            });
        }
    }

    private async Task HandleAddVariable()
    {
        var activeEnvironment = AppState.ActiveEnvironment ?? VariableGroups.SystemGroup;
        
        var keyParameters = new DialogParameters();
        keyParameters.Add("Label", "Variable key:");
        keyParameters.Add("Placeholder", "Key");
        var keyOptions = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var keyDialog = await DialogService.ShowAsync<InputDialog>("Add Variable", keyParameters, keyOptions);

        var keyResult = await keyDialog.Result;

        if (keyResult.Canceled || !(keyResult.Data is string key) || string.IsNullOrWhiteSpace(key))
            return;

        var valueParameters = new DialogParameters();
        valueParameters.Add("Label", "Variable value:");
        valueParameters.Add("Placeholder", "Value");
        var valueOptions = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog" };
        var valueDialog = await DialogService.ShowAsync<InputDialog>("Add Variable", valueParameters, valueOptions);

        var valueResult = await valueDialog.Result;

        if (!valueResult.Canceled && valueResult.Data is string value)
        {
            var variable = Variable.Create(key, value, false, activeEnvironment);
            VariableService.CreateVariable(variable);
            Snackbar.Add($"Added variable '{key}' to {activeEnvironment}", Severity.Success, opts =>
            {
                opts.SuccessIcon = SirenIcons.Variables;
            });
        }
    }

    private async Task HandleOpenSettings()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, BackgroundClass = "siren-dialog", MaxWidth = MaxWidth.Medium};
        await DialogService.ShowAsync<SettingsDialog>("Settings", options);
    }
}

